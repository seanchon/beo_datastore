import attr
from attr.validators import instance_of
from cached_property import cached_property
from datetime import datetime, timedelta
from functools import reduce
from itertools import repeat
from multiprocessing import Pool
import pandas as pd

from beo_datastore.libs.battery import (
    Battery,
    BatteryIntervalFrame,
    FixedScheduleBatterySimulation,
)
from beo_datastore.libs.intervalframe import (
    ValidationFrame288,
    ValidationIntervalFrame,
)


class DERAggregateSimulation(object):
    """
    Base class for DERAggregateSimulations. A DERAggregateSimulation takes a
    number of input meters and simulates what would happen if the same DER were
    introduced to each of those individual meters.

    A DERAggregateSimulation serves as an input to a DERCostCalculation, so it
    should provide a standardized set of results.
    """

    @property
    def pre_DER_results(self):
        """
        Return a dictionary of key, value pairs where each key is a meter and
        each value is a ValidationIntervalFrame before introducing a DER.
        """
        raise NotImplementedError()

    @property
    def post_DER_results(self):
        """
        Return a dictionary of key, value pairs where each key is a meter and
        each value is a ValidationIntervalFrame after introducing a DER.
        """
        raise NotImplementedError()

    @property
    def pre_DER_intervalframe(self):
        """
        Return a ValidationIntervalFrame that represents the aggregate interval
        readings before introducing a DER.
        """
        raise NotImplementedError()

    @property
    def post_DER_intervalframe(self):
        """
        Return a ValidationIntervalFrame that represents the aggregate interval
        readings after introducing a DER.
        """
        raise NotImplementedError()

    @property
    def net_intervalframe(self):
        """
        Return a ValidationIntervalFrame that represents the aggregate changes
        between a pre-DER and post-DER scenario.
        """
        raise NotImplementedError()


@attr.s(frozen=True)
class AggregateBatterySimulation(DERAggregateSimulation):
    """
    Container for running battery operations across many load profiles. Results
    can be generated by running create().
    """

    battery = attr.ib(validator=instance_of(Battery))
    start = attr.ib(validator=instance_of(datetime))
    end_limit = attr.ib(validator=instance_of(datetime))
    charge_schedule = attr.ib(validator=instance_of(ValidationFrame288))
    discharge_schedule = attr.ib(validator=instance_of(ValidationFrame288))
    results = attr.ib(validator=instance_of(dict))

    def __add__(self, other):
        """
        Allow AggregateBatterySimulation objects to be combined.
        """
        for name in [
            "battery",
            "start",
            "end_limit",
            "charge_schedule",
            "discharge_schedule",
        ]:
            if getattr(self, name) != getattr(other, name):
                raise ValueError(
                    "{} should equal {}.".format(
                        getattr(self, name), getattr(other, name)
                    )
                )

        return self.__class__(
            battery=self.battery,
            start=self.start,
            end_limit=self.end_limit,
            charge_schedule=self.charge_schedule,
            discharge_schedule=self.discharge_schedule,
            results={**self.results, **other.results},
        )

    @cached_property
    def meters(self):
        """
        Return generator of all meters in an aggregate simulation.
        """
        return self.results.keys()

    @cached_property
    def battery_simulations(self):
        """
        Return generator of all battery simulations in an aggregate simulation.
        """
        return self.results.values()

    @property
    def pre_DER_results(self):
        """
        Return a dictionary of key, value pairs where each key is a meter and
        each value is a ValidationIntervalFrame after introducing a Battery.
        """
        return {
            meter: intervalframe
            for meter, intervalframe in zip(
                self.meters,
                [x.pre_intervalframe for x in self.battery_simulations],
            )
        }

    @property
    def post_DER_results(self):
        """
        Return a ValidationIntervalFrame that represents the interval readings
        before introducing a Battery.
        """
        return {
            meter: intervalframe
            for meter, intervalframe in zip(
                self.meters,
                [x.post_intervalframe for x in self.battery_simulations],
            )
        }

    @cached_property
    def pre_DER_intervalframe(self):
        """
        Return a single ValidationIntervalFrame represeting the aggregate
        readings of all meter readings before a battery simulation.
        """
        return reduce(
            lambda x, y: x + y,
            [x.pre_intervalframe for x in self.battery_simulations],
            ValidationIntervalFrame(ValidationIntervalFrame.default_dataframe),
        )

    @cached_property
    def post_DER_intervalframe(self):
        """
        Return a single ValidationIntervalFrame represeting the aggregate
        readings of all meter reading after a battery simulation.
        """
        return reduce(
            lambda x, y: x + y,
            [x.post_intervalframe for x in self.battery_simulations],
            ValidationIntervalFrame(ValidationIntervalFrame.default_dataframe),
        )

    @cached_property
    def aggregate_battery_intervalframe(self):
        """
        Return a single BatteryIntervalFrame represeting the aggregate
        operations of all Batteries.
        """
        return reduce(
            lambda x, y: x + y,
            [x.battery_intervalframe for x in self.battery_simulations],
            BatteryIntervalFrame(BatteryIntervalFrame.default_dataframe),
        )

    @cached_property
    def net_intervalframe(self):
        """
        Return a ValidationIntervalFrame that represents the changes between a
        pre-battery and post-battery scenario.
        """
        return (
            ValidationIntervalFrame(ValidationIntervalFrame.default_dataframe)
            + self.aggregate_battery_intervalframe
        )

    @cached_property
    def energy_loss(self):
        """
        Return all energy lost due to battery roundtrip efficiency.
        """
        return self.aggregate_battery_intervalframe.energy_loss

    @staticmethod
    def _generate_battery_simulation(
        battery, load_intervalframe, charge_schedule, discharge_schedule
    ):
        """
        Instantiate a FixedScheduleBatterySimulation and generate full
        sequence of battery operations.
        """
        battery_simulation = FixedScheduleBatterySimulation(
            battery=battery,
            load_intervalframe=load_intervalframe,
            charge_schedule=charge_schedule,
            discharge_schedule=discharge_schedule,
        )
        battery_simulation.generate_full_sequence()

        return battery_simulation

    @classmethod
    def create(
        cls,
        battery,
        start,
        end_limit,
        meter_set,
        charge_schedule,
        discharge_schedule,
        multiprocess=False,
    ):
        """
        Run battery simulation against all simulation objects.

        :param battery: Battery
        :param start: datetime
        :param end_limit: datetime
        :param meter_set: QuerySet or set of Meters
        :param charge_schedule: ValidationFrame288
        :param discharge_schedule: ValidationFrame288
        :param multiprocess: True or False
        :return: AggregateBatterySimulation
        """
        intervalframes = [
            x.intervalframe.filter_by_datetime(start, end_limit)
            for x in meter_set
        ]

        if multiprocess:
            with Pool() as pool:
                battery_simulations = pool.starmap(
                    cls._generate_battery_simulation,
                    zip(
                        repeat(battery),
                        intervalframes,
                        repeat(charge_schedule),
                        repeat(discharge_schedule),
                    ),
                )
        else:
            battery_simulations = []
            for intervalframe in intervalframes:
                battery_simulations.append(
                    cls._generate_battery_simulation(
                        battery,
                        intervalframe,
                        charge_schedule,
                        discharge_schedule,
                    )
                )

        return cls(
            battery=battery,
            start=start,
            end_limit=end_limit,
            charge_schedule=charge_schedule,
            discharge_schedule=discharge_schedule,
            results={
                meter: battery_simulation
                for meter, battery_simulation in zip(
                    meter_set, battery_simulations
                )
            },
        )


class DERCostCalculation(object):
    """
    Base class for DERCostCalculations. A DERCostCalculation takes a
    DERAggregateSimulation as an input and calculates a net impact of that DER
    plus supporting calculations.

    A DERCostCalculation serves as an input to a report, so it should provide a
    standardized set of results.
    """

    @property
    def pre_DER_total(self):
        """
        Return the cost calculation of a pre-DER scenario.
        """
        raise NotImplementedError()

    @property
    def post_DER_total(self):
        """
        Return the cost calculation of a post-DER scenario.
        """
        raise NotImplementedError()

    @property
    def net_impact(self):
        """
        Return the cost calculation of a post-DER scenario minus the cost
        calculation of a pre-DER scenario.
        """
        raise NotImplementedError()


@attr.s(frozen=True)
class AggregateBillCalculation(DERCostCalculation):
    """
    Run bill calculations across a DERAggregateSimulation's many before and
    after load profiles.
    """

    # TODO: Break RatePlan dependency. A lib should not import from a Django
    # model and each simulation may be under a different RatePlan.

    agg_simulation = attr.ib(validator=instance_of(DERAggregateSimulation))
    rate_plan = attr.ib()
    date_ranges = attr.ib(validator=instance_of(list))
    pre_bills = attr.ib(validator=instance_of(dict))
    post_bills = attr.ib(validator=instance_of(dict))

    def __add__(self, other):
        """
        Allow AggregateBillCalculation objects to be combined.
        """
        for name in ["rate_plan", "date_ranges"]:
            if getattr(self, name) != getattr(other, name):
                raise ValueError(
                    "{} should equal {}.".format(
                        getattr(self, name), getattr(other, name)
                    )
                )

        return self.__class__(
            agg_simulation=self.agg_simulation + other.agg_simulation,
            rate_plan=self.rate_plan,
            date_ranges=self.date_ranges,
            pre_bills={**self.pre_bills, **other.pre_bills},
            post_bills={**self.post_bills, **other.post_bills},
        )

    @cached_property
    def pre_DER_total(self):
        """
        Return sum of all bills for pre-DER scenario.
        """
        return self.pre_DER_bill_totals.sum().sum()

    @cached_property
    def post_DER_total(self):
        """
        Return sum of all bills for post-DER scenario.
        """
        return self.post_DER_bill_totals.sum().sum()

    @cached_property
    def net_impact(self):
        """
        Return total billing impact (post scenario - pre scenario).
        """
        return self.post_DER_total - self.pre_DER_total

    @cached_property
    def pre_DER_bill_totals(self):
        """
        Return Pandas DataFrame containing bill totals for pre-DER scenario.
        """
        df = pd.DataFrame(
            [[x.total for x in y.values()] for y in self.pre_bills.values()]
        ).T
        df.columns = self.agg_simulation.meters
        df.index = [x[0] for x in self.date_ranges]

        return df

    @cached_property
    def post_DER_bill_totals(self):
        """
        Return Pandas DataFrame containing bill totals for post-DER scenario.
        """
        df = pd.DataFrame(
            [[x.total for x in y.values()] for y in self.post_bills.values()]
        ).T
        df.columns = self.agg_simulation.meters
        df.index = [x[0] for x in self.date_ranges]

        return df

    @cached_property
    def net_DER_bill_totals(self):
        """
        Return Pandas DataFrame containing net difference of pre-DER bills
        minus post-DER bills.
        """
        return self.post_DER_bill_totals - self.pre_DER_bill_totals

    @classmethod
    def create(
        cls, agg_simulation, rate_plan, date_ranges, multiprocess=False
    ):
        """
        Create pre-and-post-DER bills for all simulations.

        :param agg_simulation: DERAggregateSimulation
        :param rate_plan: RatePlan object
        :param date_ranges: list of start, end_limit datetime tuples
        :param multiprocess: True to multiprocess
        :return: AggregateBillCalculation
        """
        pre_bills = cls.generate_bills(
            meters=agg_simulation.pre_DER_results,
            rate_plan=rate_plan,
            date_ranges=date_ranges,
            multiprocess=multiprocess,
        )
        post_bills = cls.generate_bills(
            meters=agg_simulation.post_DER_results,
            rate_plan=rate_plan,
            date_ranges=date_ranges,
            multiprocess=multiprocess,
        )

        return cls(
            agg_simulation=agg_simulation,
            rate_plan=rate_plan,
            date_ranges=date_ranges,
            pre_bills=pre_bills,
            post_bills=post_bills,
        )

    @classmethod
    def generate_bills(
        cls, meters, rate_plan, date_ranges, multiprocess=False
    ):
        simulation_bills = {}
        for meter, intervalframe in meters.items():
            results = rate_plan.generate_many_bills(
                intervalframe=intervalframe,
                date_ranges=date_ranges,
                multiprocess=multiprocess,
            )
            simulation_bills[meter] = results

        return simulation_bills


@attr.s(frozen=True)
class AggregateGHGCalculation(DERCostCalculation):
    """
    Run GHG calculations across a DERAggregateSimulation's many before and
    after load profiles.
    """

    agg_simulation = attr.ib(validator=instance_of(DERAggregateSimulation))
    ghg_frame288 = attr.ib(validator=instance_of(ValidationFrame288))

    def __add__(self, other):
        """
        Allow AggregateGHGCalculation objects to be combined.
        """
        if self.ghg_frame288 != other.ghg_frame288:
            raise ValueError(
                "{} should equal {}.".format(
                    self.ghg_frame288, other.ghg_frame288
                )
            )

        return self.__class__(
            agg_simulation=self.agg_simulation + other.agg_simulation,
            ghg_frame288=self.ghg_frame288,
        )

    @cached_property
    def pre_DER_total(self):
        """
        Return total tons of CO2 pre-DER.
        """
        return self.ghg_before_frame288.dataframe.sum().sum()

    @cached_property
    def post_DER_total(self):
        """
        Return total tons of CO2 post-DER.
        """
        return self.ghg_after_frame288.dataframe.sum().sum()

    @cached_property
    def net_impact(self):
        """
        Return total GHG impact (post scenario - pre scenario).
        """
        return self.post_DER_total - self.pre_DER_total

    @cached_property
    def ghg_before_frame288(self):
        """
        Return 288 frame of month-hour GHG emissions pre-DER.
        """
        return (
            self.agg_simulation.pre_DER_intervalframe.total_frame288
            * self.ghg_frame288
        )

    @cached_property
    def ghg_after_frame288(self):
        """
        Return 288 frame of month-hour GHG emissions post-DER.
        """
        return (
            self.agg_simulation.post_DER_intervalframe.total_frame288
            * self.ghg_frame288
        )

    @cached_property
    def comparison_table(self):
        """
        Return table of monthly pre-DER and post-DER values.
        """
        df = pd.merge(
            pd.DataFrame(self.ghg_before_frame288.dataframe.sum()),
            pd.DataFrame(self.ghg_after_frame288.dataframe.sum()),
            how="inner",
            left_index=True,
            right_index=True,
        )
        return df.append(df.sum().rename("Total")).rename(
            columns={"0_x": "before", "0_y": "after"}
        )

    @classmethod
    def create(cls, agg_simulation, ghg_frame288):
        """
        Alias for __init__().
        """
        return cls(agg_simulation=agg_simulation, ghg_frame288=ghg_frame288)


@attr.s(frozen=True)
class AggregateResourceAdequacyCalculation(DERCostCalculation):
    """
    Run RA calculations across a DERAggregateSimulation's many before and
    after load profiles.
    """

    agg_simulation = attr.ib(validator=instance_of(DERAggregateSimulation))
    system_profile_intervalframe = attr.ib(
        validator=instance_of(ValidationIntervalFrame)
    )

    @cached_property
    def system_profile_year(self):
        years = set(self.system_profile_intervalframe.dataframe.index.year)
        if len(years) != 1:
            raise AttributeError(
                "Unique year not detected in {}.".format(years)
            )
        else:
            return years.pop()

    @cached_property
    def pre_DER_total(self):
        """
        Return sum of all monthly system peaks pre-DER.
        """
        system_peaks = self.pre_DER_system_intervalframe.maximum_frame288
        return system_peaks.dataframe.max().sum()

    @cached_property
    def post_DER_total(self):
        """
        Return sum of all monthly system peaks post-DER.
        """
        system_peaks = self.post_DER_system_intervalframe.maximum_frame288
        return system_peaks.dataframe.max().sum()

    @cached_property
    def net_impact(self):
        """
        Return total RA impact (post scenario - pre scenario) (kW).
        """
        return self.post_DER_total - self.pre_DER_total

    @cached_property
    def pre_DER_system_intervalframe(self):
        """
        Return pre-DER SystemProfileIntervalFrame.
        """
        return self.system_profile_intervalframe

    @cached_property
    def post_DER_system_intervalframe(self):
        """
        Add ValidationIntervalFrame consisting of net kW changes due to a DER.
        The ValidationIntervalFrame index year will be changed so that the
        SystemProfile dates align with ValidationIntervalFrame dates.
        """
        intervalframe = self.agg_simulation.net_intervalframe
        if (
            intervalframe.end_limit_timestamp - intervalframe.start_timestamp
        ) > timedelta(days=366):
            raise RuntimeError(
                "ValidationIntervalFrame must be one year or less."
            )

        # shift BatteryIntervalFrame year to align with SystemProfile
        updated_index = intervalframe.dataframe.index.map(
            lambda t: t.replace(year=self.system_profile_year)
        )
        intervalframe.dataframe.index = updated_index

        return intervalframe + self.system_profile_intervalframe

    @cached_property
    def comparison_table(self):
        """
        Return table of monthly pre-DER and post-DER values.
        """
        pre_DER_max_288 = self.pre_DER_system_intervalframe.maximum_frame288
        post_DER_max_288 = self.post_DER_system_intervalframe.maximum_frame288
        df = pd.merge(
            pd.DataFrame(pre_DER_max_288.dataframe.max()),
            pd.DataFrame(post_DER_max_288.dataframe.max()),
            how="inner",
            left_index=True,
            right_index=True,
        )
        return df.append(df.sum().rename("Total")).rename(
            columns={"0_x": "before", "0_y": "after"}
        )

    @classmethod
    def create(cls, agg_simulation, system_profile_intervalframe):
        """
        Alias for __init__().
        """
        return cls(
            agg_simulation=agg_simulation,
            system_profile_intervalframe=system_profile_intervalframe,
        )
