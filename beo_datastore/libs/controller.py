import attr
from attr.validators import instance_of
from cached_property import cached_property
from datetime import datetime
from functools import reduce
from itertools import repeat
from multiprocessing import Pool
import pandas as pd

from beo_datastore.libs.battery import (
    Battery,
    BatteryIntervalFrame,
    FixedScheduleBatterySimulation,
)
from beo_datastore.libs.intervalframe import (
    ValidationFrame288,
    ValidationIntervalFrame,
)


class DERAggregateSimulation(object):
    """
    Base class for DER simulators.
    """

    pass


@attr.s(frozen=True)
class AggregateBatterySimulation(DERAggregateSimulation):
    """
    Container for running battery operations across many load profiles. Results
    can be generated by running create().
    """

    battery = attr.ib(validator=instance_of(Battery))
    start = attr.ib(validator=instance_of(datetime))
    end_limit = attr.ib(validator=instance_of(datetime))
    charge_schedule = attr.ib(validator=instance_of(ValidationFrame288))
    discharge_schedule = attr.ib(validator=instance_of(ValidationFrame288))
    results = attr.ib(validator=instance_of(dict))

    def __add__(self, other):
        """
        Allow AggregateBatterySimulation objects to be combined.
        """
        for name in [
            "battery",
            "start",
            "end_limit",
            "charge_schedule",
            "discharge_schedule",
        ]:
            if getattr(self, name) != getattr(other, name):
                raise ValueError(
                    "{} should equal {}.".format(
                        getattr(self, name), getattr(other, name)
                    )
                )

        return self.__class__(
            battery=self.battery,
            start=self.start,
            end_limit=self.end_limit,
            charge_schedule=self.charge_schedule,
            discharge_schedule=self.discharge_schedule,
            results={**self.results, **other.results},
        )

    @cached_property
    def meters(self):
        """
        Return generator of all meters in aggregate simulation.
        """
        return self.results.keys()

    @cached_property
    def battery_simulations(self):
        """
        Return generator of all battery simulations in aggregate simulation.
        """
        return self.results.values()

    @cached_property
    def pre_intervalframes(self):
        """
        Return list of all meter readings (ValidationIntervalFrame) before a
        DER simulation.
        """
        return [x.pre_intervalframe for x in self.battery_simulations]

    @cached_property
    def pre_meter_intervalframes(self):
        """
        Return a dictionary of all meters and meter readings
        (ValidationIntervalFrame) before a DER simulation.
        """
        return {
            meter: intervalframe
            for meter, intervalframe in zip(
                self.meters, self.pre_intervalframes
            )
        }

    @cached_property
    def aggregate_pre_intervalframe(self):
        """
        Return a single ValidationIntervalFrame represeting the aggregate
        readings of all meter readings before a DER simulation.
        """
        return reduce(
            lambda x, y: x + y,
            self.pre_intervalframes,
            ValidationIntervalFrame(ValidationIntervalFrame.default_dataframe),
        )

    @cached_property
    def post_intervalframes(self):
        """
        Return list of all meter readings (ValidationIntervalFrame) after a DER
        simulation.
        """
        return [x.post_intervalframe for x in self.battery_simulations]

    @cached_property
    def post_meter_intervalframes(self):
        """
        Return a dictionary of all meters and meter readings
        (ValidationIntervalFrame) after a DER simulation.
        """
        return {
            meter: intervalframe
            for meter, intervalframe in zip(
                self.meters, self.post_intervalframes
            )
        }

    @cached_property
    def aggregate_post_intervalframe(self):
        """
        Return a single ValidationIntervalFrame represeting the aggregate
        readings of all meter reading after a DER simulation.
        """
        return reduce(
            lambda x, y: x + y,
            self.post_intervalframes,
            ValidationIntervalFrame(ValidationIntervalFrame.default_dataframe),
        )

    @cached_property
    def aggregate_battery_intervalframe(self):
        """
        Return a single BatteryIntervalFrame represeting the aggregate
        operations of all Batteries.
        """
        return reduce(
            lambda x, y: x + y,
            [x.battery_intervalframe for x in self.battery_simulations],
            BatteryIntervalFrame(BatteryIntervalFrame.default_dataframe),
        )

    @cached_property
    def aggregate_energy_loss(self):
        """
        Return all energy lost due to battery roundtrip efficiency.
        """
        return self.aggregate_battery_intervalframe.energy_loss

    @staticmethod
    def _generate_battery_simulation(
        battery, load_intervalframe, charge_schedule, discharge_schedule
    ):
        """
        Instantiate a FixedScheduleBatterySimulation and generate full
        sequence of battery operations.
        """
        battery_simulation = FixedScheduleBatterySimulation(
            battery=battery,
            load_intervalframe=load_intervalframe,
            charge_schedule=charge_schedule,
            discharge_schedule=discharge_schedule,
        )
        battery_simulation.generate_full_sequence()

        return battery_simulation

    @classmethod
    def create(
        cls,
        battery,
        start,
        end_limit,
        meter_set,
        charge_schedule,
        discharge_schedule,
        multiprocess=False,
    ):
        """
        Run battery simulation against all simulation objects.

        :param battery: Battery
        :param start: datetime
        :param end_limit: datetime
        :param meter_set: QuerySet or set of Meters
        :param charge_schedule: ValidationFrame288
        :param discharge_schedule: ValidationFrame288
        :param multiprocess: True or False
        :return: AggregateBatterySimulation
        """
        intervalframes = [
            x.intervalframe.filter_by_datetime(start, end_limit)
            for x in meter_set
        ]

        if multiprocess:
            with Pool() as pool:
                battery_simulations = pool.starmap(
                    cls._generate_battery_simulation,
                    zip(
                        repeat(battery),
                        intervalframes,
                        repeat(charge_schedule),
                        repeat(discharge_schedule),
                    ),
                )
        else:
            battery_simulations = []
            for intervalframe in intervalframes:
                battery_simulations.append(
                    cls._generate_battery_simulation(
                        battery,
                        intervalframe,
                        charge_schedule,
                        discharge_schedule,
                    )
                )

        return cls(
            battery=battery,
            start=start,
            end_limit=end_limit,
            charge_schedule=charge_schedule,
            discharge_schedule=discharge_schedule,
            results={
                meter: battery_simulation
                for meter, battery_simulation in zip(
                    meter_set, battery_simulations
                )
            },
        )


@attr.s(frozen=True)
class AggregateBillCalculation(object):
    """
    Run bill calculations across a DERAggregateSimulation's many before and
    after load profiles.
    """

    # TODO: Break RatePlan dependency. A lib should not import from a Django
    # model and each simulation may be under a different RatePlan.

    agg_simulation = attr.ib(validator=instance_of(DERAggregateSimulation))
    rate_plan = attr.ib()
    date_ranges = attr.ib(validator=instance_of(list))
    pre_bills = attr.ib(validator=instance_of(dict))
    post_bills = attr.ib(validator=instance_of(dict))

    def __add__(self, other):
        """
        Allow AggregateBillCalculation objects to be combined.
        """
        for name in ["rate_plan", "date_ranges"]:
            if getattr(self, name) != getattr(other, name):
                raise ValueError(
                    "{} should equal {}.".format(
                        getattr(self, name), getattr(other, name)
                    )
                )

        return self.__class__(
            agg_simulation=self.agg_simulation + other.agg_simulation,
            rate_plan=self.rate_plan,
            date_ranges=self.date_ranges,
            pre_bills={**self.pre_bills, **other.pre_bills},
            post_bills={**self.post_bills, **other.post_bills},
        )

    @cached_property
    def pre_DER_bill_totals(self):
        """
        Return Pandas DataFrame containing bill totals for pre-DER scenario.
        """
        df = pd.DataFrame(
            [[x.total for x in y.values()] for y in self.pre_bills.values()]
        ).T
        df.columns = self.agg_simulation.meters
        df.index = [x[0] for x in self.date_ranges]

        return df

    @cached_property
    def pre_DER_bill_grand_total(self):
        """
        Return sum of all bills for pre-DER scenario.
        """
        return self.pre_DER_bill_totals.sum().sum()

    @cached_property
    def post_DER_bill_totals(self):
        """
        Return Pandas DataFrame containing bill totals for post-DER scenario.
        """
        df = pd.DataFrame(
            [[x.total for x in y.values()] for y in self.post_bills.values()]
        ).T
        df.columns = self.agg_simulation.meters
        df.index = [x[0] for x in self.date_ranges]

        return df

    @cached_property
    def post_DER_bill_grand_total(self):
        """
        Return sum of all bills for post-DER scenario.
        """
        return self.post_DER_bill_totals.sum().sum()

    @cached_property
    def net_DER_bill_totals(self):
        """
        Return Pandas DataFrame containing net difference of pre-DER bills
        minus post-DER bills.
        """
        return self.post_DER_bill_totals - self.pre_DER_bill_totals

    @cached_property
    def net_impact(self):
        """
        Return total billing impact (post scenario - pre scenario).
        """
        return self.post_DER_bill_grand_total - self.pre_DER_bill_grand_total

    @classmethod
    def create(
        cls, agg_simulation, rate_plan, date_ranges, multiprocess=False
    ):
        """
        Create pre-and-post-DER bills for all simulations.

        :param agg_simulation: DERAggregateSimulation
        :param rate_plan: RatePlan object
        :param date_ranges: list of start, end_limit datetime tuples
        :param multiprocess: True to multiprocess
        :return: AggregateBillCalculation
        """
        pre_bills = cls.generate_bills(
            meter_intervalframes=agg_simulation.pre_meter_intervalframes,
            rate_plan=rate_plan,
            date_ranges=date_ranges,
            multiprocess=multiprocess,
        )
        post_bills = cls.generate_bills(
            meter_intervalframes=agg_simulation.post_meter_intervalframes,
            rate_plan=rate_plan,
            date_ranges=date_ranges,
            multiprocess=multiprocess,
        )

        return cls(
            agg_simulation=agg_simulation,
            rate_plan=rate_plan,
            date_ranges=date_ranges,
            pre_bills=pre_bills,
            post_bills=post_bills,
        )

    @classmethod
    def generate_bills(
        cls, meter_intervalframes, rate_plan, date_ranges, multiprocess=False
    ):
        simulation_bills = {}
        for meter, intervalframe in meter_intervalframes.items():
            results = rate_plan.generate_many_bills(
                intervalframe=intervalframe,
                date_ranges=date_ranges,
                multiprocess=multiprocess,
            )
            simulation_bills[meter] = results

        return simulation_bills


@attr.s(frozen=True)
class AggregateGHGCalculation(object):
    """
    Run GHG calculations across a DERAggregateSimulation's many before and
    after load profiles.
    """

    agg_simulation = attr.ib(validator=instance_of(DERAggregateSimulation))
    ghg_frame288 = attr.ib(validator=instance_of(ValidationFrame288))

    def __add__(self, other):
        """
        Allow AggregateGHGCalculation objects to be combined.
        """
        if self.ghg_frame288 != other.ghg_frame288:
            raise ValueError(
                "{} should equal {}.".format(
                    self.ghg_frame288, other.ghg_frame288
                )
            )

        return self.__class__(
            agg_simulation=self.agg_simulation + other.agg_simulation,
            ghg_frame288=self.ghg_frame288,
        )

    @cached_property
    def ghg_before_frame288(self):
        return (
            self.agg_simulation.aggregate_pre_intervalframe.total_frame288
            * self.ghg_frame288
        )

    @cached_property
    def ghg_before_total(self):
        return self.ghg_before_frame288.dataframe.sum().sum()

    @cached_property
    def ghg_after_frame288(self):
        return (
            self.agg_simulation.aggregate_post_intervalframe.total_frame288
            * self.ghg_frame288
        )

    @cached_property
    def ghg_after_total(self):
        return self.ghg_after_frame288.dataframe.sum().sum()

    @cached_property
    def comparison_table(self):
        df = pd.merge(
            pd.DataFrame(self.ghg_before_frame288.dataframe.sum()),
            pd.DataFrame(self.ghg_after_frame288.dataframe.sum()),
            how="inner",
            left_index=True,
            right_index=True,
        )
        return df.append(df.sum().rename("Total")).rename(
            columns={"0_x": "before", "0_y": "after"}
        )

    @cached_property
    def net_impact(self):
        """
        Return total GHG impact (post scenario - pre scenario).
        """
        return self.ghg_after_total - self.ghg_before_total

    @classmethod
    def create(cls, agg_simulation, ghg_frame288):
        """
        Alias for __init__().
        """
        return cls(agg_simulation=agg_simulation, ghg_frame288=ghg_frame288)
